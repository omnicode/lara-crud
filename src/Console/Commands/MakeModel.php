<?php

namespace LaraCrud\Console\Commands;

use LaraMake\Exceptions\LaraCommandException;
use LaraModel\Models\LaraModel;
use LaraMake\Console\Commands\Abstracts\ClassMaker;
use LaraSupport\Facades\LaraDB;

class MakeModel extends ClassMaker
{
//$ php artisan l:crud-model _db
//$ php artisan l:crud-model _db:table_names
//$ php artisan l:crud-model _db:table_names_separate_with_comma --with-relations
//$ php artisan l:crud-model _db:cars,brands
//$ php artisan l:crud-model _db:cars,brands --with-relations
//$ php artisan l:crud-model _db:cars,brands --with-relations --detailed

    /**
     * @var string
     */
    public $commandName = 'crud-model';

    /**
     * @var string
     */
    public $instance = 'Model';

    /**
     * @var string
     */
    protected $description = 'Make flexible Models with extends ' . LaraModel::class;

    /**
     * @var bool
     */
    public $makeBase = true;

    /**
     * @var string
     */
    public $parent = LaraModel::class;

    /**
     * @var array
     */
    protected $defaultOptions = [
        'confirm',
        'detailed',
        'with-relations',
        'confirm-back-slash',
        'confirm-overwrite',
        'choice-default',
        'path' => 'path=',
        'root-path' => 'root-path=',
    ];

    public $__withRelations;
    public $__detailed;

    public function configure()
    {
        if (empty($this->rootPath)) {
            $this->rootPath = config('lara_crud.root_namespaces.model', '');
        }

        parent::configure(); // TODO: Change the autogenerated stub
    }

    protected function makeBasedDb($pattern, $content)
    {
        $dbStructure = LaraDB::getDBStructure();
        $dbTables = array_keys($dbStructure);
        if ($pattern == config('lara_make.by_database')) {
            $tables = $dbTables;
        } else {
            // @TODO ':' make dynamically
            $str = str_replace_first(config('lara_make.by_database') . ':', '', $pattern);
            $tables = explode(',', $str);
            $diffTables = array_diff($tables, $dbTables);
            if($diffTables) {
                $message = $this->attentionSprintF(
                    'Only %s table can make by database. %s tables absent in your db please fix it',
                    implode(',', $dbStructure),
                    implode(',', $diffTables)
                );
                throw new LaraCommandException($message);
            }
        }
        $tables = array_diff($tables, $this->ignoreTables);
        $this->__confirm = true;
        if (false == $this->createBasePattern($content)) {
            // @TODO show dont saved message
            return false;
        }

        $data = [];
        foreach ($dbStructure as $table => $columnsInfo) {

            if (in_array($table, $this->ignoreTables)) {
                continue;
            }

            $pattern = str_singular(title_case($table));
            $pattern = str_replace('_', '', $pattern);
            $data[$table]['pattern'] = $pattern;
            $data[$table]['listable'] = [];
            $data[$table]['showable'] = [];
            $data[$table]['indexable'] = [];

            foreach ($columnsInfo as $column => $_data) {

                if ('PRI' == $_data['key']) {
                    continue;
                }

                if (in_array($column, $this->ignoreColumns)) {
                    continue;
                }

                if (isset($this->ignoreTableColumns[$table]) && in_array($column, $this->ignoreTableColumns[$table])) {
                    continue;
                }


                if (ends_with($column, '_id')) {
                    $relation = str_replace_last('_id', '', $column);
                    $data[$table]['methods']['belongs_to'][] = $relation;
                    $data[str_plural($relation)]['methods']['has_many'][] = $table;
                    $data[$table]['_relations'][] = $relation;
                    $data[str_plural($relation)]['_relations'][] = $table;
                    if($this->__withRelations) {
                        $tables[] = $table;
                        $tables[] = str_plural($relation);
                    }
                }

                $data[$table]['columns'][] = $column;

                $indexable = [];
                if (in_array($_data['type'], ['enum', 'char', 'varchar', 'datetime', 'date', 'double', 'decimal'])) {
                    $indexable['name'] = $column;
                    $indexable['sortable'] = true;
                } elseif(in_array($_data['type'], ['smallint', 'int', 'text', 'tinyint'])) {
                    if (!ends_with($column, '_id')) {
                        $indexable['name'] = $column;
                        $indexable['sortable'] = true;
                    }
                } else {
                    // @TODO
//                    dd($_data['type'], $column);
                }
                if (!empty($indexable)) {
                    $data[$table]['indexable'][] = $indexable;
                }
                $data[$table]['showable'][] = [
                    'name' => $column
                ];
                if (in_array($_data['type'], ['char','varchar'])) {
                    if (ends_with($column, '_path')) {
                        continue;
                    }
                    $data[$table]['listable'][$column] = $_data['length'];
                }

            }
        }
        foreach ($data as $table => $info) {
            // @TODO dynamically add all needs table $tables
            if (!in_array($table, $tables)) {
                continue;
            }

            if (in_array($table, $this->ignoreTables)) {
                continue;
            }
            $this->__use = [];
            if (!isset($info['pattern'])) {
                continue;
            }
            $this->__pattern = $info['pattern'];

            $this->__property = [];
            if ($table != str_plural($table)) {
                $this->__property['protected']['table'] = $table;
            }

            $this->__property['public'] = [
                'fillable' => $info['columns'],
            ];

            if (!empty($info['_relations'])) {
                $this->__property['protected']['_relations'] = $info['_relations'];
            }


            if ($this->__detailed) {
                if (!empty($info['indexable'])) {
                    $this->__property['protected']['indexable'] = $info['indexable'];
                }

                if (!empty($info['showable'])) {
                    $this->__property['protected']['showable'] = $info['showable'];
                }

                if (!empty($info['listable'])) {
                    $listable = $info['listable'];
                    $listable = array_flip(array_reverse($listable));
                    ksort($listable);
                    $this->__property['protected']['listable'] = [
                        'name' => head($listable),
                        'value' => head($listable)
                    ];
                }
            }

            if (!empty($info['methods'])) {
                $methods = [];
                if (!empty($info['methods']['belongs_to'])) {
                    foreach ($info['methods']['belongs_to'] as $relation) {
                        $_table = str_plural($relation);

                        $template = empty($data[$_table]['pattern'])
                            ? TAB . TAB . TAB . 'return true;// @TODO fix'
                            : TAB . TAB . TAB . sprintf('return $this->belongsTo(%s::class);', $data[$_table]['pattern']) ;
                        $methods[] = [
                            'name' => $relation,
                            'content' => $template,
                        ];
                    }
                }
                if (!empty($info['methods']['has_many'])) {
                    foreach ($info['methods']['has_many'] as $_table) {
                        $template = empty($data[$_table]['pattern'])
                            ? TAB . TAB . TAB . 'return true;// @TODO fix'
                            : TAB . TAB . TAB . sprintf('return $this->hasMany(%s::class);', $data[$_table]['pattern']) ;
                        $methods[] = [
                            'name' => $_table,
                            'content' => $template,
                        ];
                    }
                }
                $this->__method = [
                    'public' => $methods
                ];
            }
            $this->createFileBy($this->__pattern, $content);
        }

    }
}